# 跳表

> 链表加多级索引的结构，就是跳表。

跳表其实是在有序的链表的基础上发展起来的，假如我们有如下这样一个单链表，最左侧的为头结点

![skipList](img/skipList.png)

在这样的链表中查找一个数据，需要从头开始逐个比较，时间复杂度为 O(n)。插入和删除本身的操作为 O(1)，但是因为都需要先找到其前节点，所以实际的时间复杂度也为 O(n)

假如我们每相邻两个节点增加一个指针，并让指针指向下一个节点

![skipList2](img/skipList2.png)

这样新加的指针其实又组成了一个新的链表，而且新的链表包含的节点只有原来的一半。此时假如我们想找值为 7 的这个节点，我可以从下图中标红的路线进行查找。

![skipList2](img/skipList3.png)

因此我们可以看到，我们加了一层指针之后，查找一个结点需要遍历的次数变少了，也就是查找效率变高了，那我们再加几层呢？

这样的查找方式就非常类似于一个二分查找，使得查找的时间复杂度可以降低到 O(logn)。但这种插入方式其实是存在一定的问题的，当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某两个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。

作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。

## Tips

虽然空间复杂度是 O(n)，但是在实际工作中，我们要排序的都是数据量很多的对象，而我们建立索引时只需要少量排序需要的数据即可，这部分空间与对象占用的空间相比其实很多情况下都是可以忽略不计的了。

## 参考链接

https://juejin.im/post/6844903446475177998#heading-6
